# 100 Days Of Code - Log
### Day 1: May 22, 2019, Wednesday

**Today's Progress**: Began Python tutorials at Alec’s Basketball Game. Went through the initial chapters. 

**Thoughts:** Overall, the tutorial proved to be highly informative. I am certainly looking forward to continuing my work tomorrow. I learned more about the Python Interpreter and how it functions. 

**Link(s) to work:** [Initial Python Tutorials](https://docs.python.org/2/tutorial/appetite.html)


### Day 2: May 23, 2019, Thursday

**Today's Progress**: Continued with Python Tutorials- Went through more chapters. Learned more of list comprehensions, which are very cool in that they consolidate things effectively and efficiently. 

**Thoughts**: I learned more of Python Syntax as well, proved to be a very important day. Made many connections in terms realizing Python’s ease and how it serves as a versatile, higher level programming language!!

**Link(s) to work**: [Additional Python Tutorials](https://docs.python.org/2/tutorial/introduction.html)


### Day 3: May 24, Friday

**Today's Progress**: I completed additional tutorials for python 2.7 and was able to predict programs before seeing their solutions, particularly in the tuples tutorials. 

**Thoughts** Although Python syntax is relatively new to me, I am excited to say that my understanding of proper syntax and appealing formatting has increased tremendously, in particular thanks to PEP 8 and coding style documentation. 

**Link(s) to work:** [Tuples Tutorials](https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences)


### Day 4: May 25, 2019, Saturday

**Today's Progress**: Dove into Lambdas, followed by data structures in their entirety. I also predicted the programs for the slice function.

**Thoughts:**: I made great progress on my understanding of the slice function and how it’s steps can be indicated, in addition to the starting and ending indices. 
**Link to work:** [Data Structure Tutorials](https://docs.python.org/2/tutorial/datastructures.html#)


### Day 5: May 26, 2019, Sunday 

**Today's Progress**: Learned a lot about nesting and looping techniques. Began to learn of modules and writing scripts outside of the Python Interpreter. Although I had prior experience with this, I had never taken the time to distinguish the specialized usages between the Python Interpreter and scripts. I also learned here about bashrc and how it is a shell script that bash runs whenever it is started interactively! 

**Thoughts**: I made a lot of connections today surrounding the importance of having scripts outside of the Python Interpreter. 

**Link(s) to work:** [Looping-Techniques Tutorials](https://docs.python.org/2/tutorial/datastructures.html#looping-techniques)


### Day 6: May 27, Monday

**Today's Progress**: I explored the Python Libraries in addition to API’s. 

**Thoughts** I realized much of the importance of API’s and how they enable two software programs to communicate with one another. I also had never appreciated the origin of numpy prior to exploring the Python Libraries and the functions within them. 

**Link(s) to work:** [Python Libraries Overview](https://docs.python.org/2/tutorial/stdlib.html)

### Day 7: May 28, Tuesday

**Today's Progress**: Took leave from the Python Tutorials and focused on MoveIt!. Followed their Panda Robot tutorial and implemented it myself on a new virtual machine with a distinct set-up from the more familiar Baxter Platform.

**Thoughts:** Not only did I learn so much more of MoveIt! and it’s framework, I learned how to create a virtual machine from the ground up, without any pre installed and or pre configured packages. I also learned how to transfer Virtual Machines across computers, as my older laptop, which was a Dell Latitude E7440, proved to have less RAM and therefore did not function as well as my newer laptop, being a Dell E7470 with a CORE i7 processor.

**Link to work:** [MoveIt Tutorials](https://ros-planning.github.io/moveit_tutorials/)


### Day 8: May 29, Wednesday

**Today's Progress**: Returned to Python Tutorials. Learned of dir() and its capabilities. I also learned of packages and how Python searches through the directories on sys.path.

**Thoughts**: Learned of the distinction between RAM and CPUs in a more in depth sort of light. 

**Link(s) to work**: [Dir() Tutorial](https://docs.python.org/2/tutorial/modules.html#the-dir-function)


### Day 9: May 30, Thursday

**Today's Progress**: Learned of Class Objects and Instance Objects through the Class segment of the Python 2.7 tutorials.

**Thoughts** I felt accomplished after working through these tutorials. Object oriented programming and the conceptual piece of it has always been extremely interesting and I am curious to learn more. Glad I took time to complete this, as I learned of desktop apps and quiz applications holistically, in terms of the different ways one can go about creating one. 

**Link(s) to work:**
[Class Objects Tutorial](https://docs.python.org/2/tutorial/classes.html#class-objects)


### Day 10: May 31, Friday

**Today's Progress**: Began to fulfill a series of Python Challenges I stumbled across online. Proved to be very fun and informative. 

**Thoughts:** It was an exhilarating process to try and fulfill as many challenges as possible in a single sitting. Troubleshooting challenges has also become far easier as I become more familiar with the language. 

**Link to work:** [Python Challenges](https://github.com/zhiwehu/Python-programming-exercises/commit/22bb9b343f009a1d710117b02f5b278e0761094f)


### Day 11: June 1, Saturday

**Today's Progress**: Continued to work through various Python Challenges. Came across a few tougher ones that took a little longer than expected to debug but all in all I learned more from them than through any individual riddle previously. 

**Thoughts** I have realized that any problem can be solved in programming and there is actually an infinite number of ways to go about solving a problem, and through perseverance one can always achieve their objectives in programming!

**Link(s) to work** [Python Challenges](https://github.com/zhiwehu/Python-programming-exercises/commit/22bb9b343f009a1d710117b02f5b278e0761094f)


### Day 12: June 2, Sunday

**Today's Progress**: I became inspired to pursue additional, more challenging Python Challenges and started working backwards from the bottom of the Python Challenges files. 

**Thoughts:** These programs allowed me to realize more of the significance of list comprehensions and slicing, how they can be used to overcome challenges and cause a program to function more easily. I also began to play around with these functions in order to see how they could be of use in my Baxter collision detection script.

**Link to work:** [Python Challenges](https://github.com/zhiwehu/Python-programming-exercises/commit/22bb9b343f009a1d710117b02f5b278e0761094f)


### Day 13: June 3, Monday

**Today's Progress**: Today I completed additional Python Challenges. I also reviewed the function tutorials in order to increase comprehension of the material. 

**Thoughts**: I learned more of the importance of properly indenting methods in Python in order to ensure that they execute according to their designated purposes. 

**Link(s) to work**: [Defining Functions Tutorial] (https://docs.python.org/2/tutorial/controlflow.html#defining-functions)


### Day 14: June 4, Tuesday

**Today's Progress**: I have continued to work through Python Challenges and also began to review my Baxter Collision Detection script. After doing so, I reviewed the Baxter Platform Installation Guide which proved to be very helpful in reforming an understanding of how MoveIt! is integrated with Gazebo and the motion planning methods. 

**Thoughts**: I sincerely appreciate the thorough documentation that exists for this particular project. It has simply broken down resources that I can use in order to fulfill my objectives in the collision detection and path following methods. 


**Link(s) to work** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 15: June 5, Wednesday

**Today's Progress**: Continued to work with MoveIt! In VirtualBox. Had to learn how to configure two different VMs, one for the ROS/ MoveIt! tutorial and one for my Baxter Platform. 

**Thoughts:** I worked through challenges with the VM and sincerely enjoyed overcoming all of these challenges on my own. 

**Link to work:**  [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 16: June 6, Thursday

**Today's Progress**: Determined that previous Baxter Collision Detection Script required complete overhaul.

**Thoughts**: Having a better understanding of various concepts, I now understand that my old project will not meet my objectives in its current state. Therefore, I decided to write a new script for the project. 

**Link(s) to work**: [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 17: June 7, Friday

**Today's Progress**: Read over ROS materials and tutorials, doing so in a separate virtual machine from the baxter platform and MoveIt! Tutorial. Also read into the description of the joint_trajectory_action_server. Formulated new plan for script. 

**Thoughts** I feel as though I have a clear idea of the following steps I have to take in order to write my baxter collision detection program. 

**Link(s) to work**  [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 18: June 8, Saturday

**Today's Progress**: Reviewed tutorial scripts using robot_controller.py and scene_controller.py from the Baxter Platform Installation Guide. Used main.py as a starting place for my program. 

**Thoughts:** The main.py program allowed me to test my environment and allowed me to ensure that all was set up according to plan. Ie. the joint_trajectory_action_server could obtain the join_angles of the robot’s arm at any given time throughout moving, etc. 

**Link to work:**  [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 19: June 9, Sunday

**Today's Progress**: Worked through VM challenges, while also configuring my scene to contain a tall block and a table for which the block to be placed on. 

**Thoughts**: Learned that it is not always best to use items that are taller than they are wide as they may fall over due to gravity. 

**Link(s) to work**:  [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 20: June 10, Monday

**Today's Progress**: Began to implement trajectory following method. Had to figure out the proper syntax required to ask for a trajectory to be created with three points or joint_positions. 

**Thoughts** After troubleshooting the issue, it turned out to be that the points should have been separated by commas rather than plus signs in a trajectory list. I felt satisfied to have overcome this particular challenge as it was a rather time consuming one. 

**Link(s) to work** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 21: June 11, Tuesday

**Today's Progress**: Revisited Python tutorials and challenges to better acquire the programming language. Continued to troubleshoot points to comprise my trajectory. 

**Thoughts:** I believe there is a way in which I can test for valid joint positions more quickly and in a more efficient way than simply guessing and checking whether joint position values are or are not valid positions. 

**Link to work:**  [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 22: June 12, Wednesday

**Today's Progress**: Began to create method that would generate valid joint positions (10 of them in total).

**Thoughts**: Worked through different ways to approach the problem. Debating whether to organize the position values by row or column would be simpler. 

**Link(s) to work**:  [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 23: June 13, Thursday

**Today's Progress**: Continued to work through valid joint position method in an attempt to get it to return joint values in a readable and recognizable format. 

**Thoughts**: Satisfied with the results of the joint_positions. Will configure trajectory and identify 3 trajectory points after finalizing the collision detection method. 

**Link(s) to work**: [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 24: June 14, Friday

**Today's Progress**: Began to implement collision detection program. Had to work through making program compatible with the robot_controller checkCollision().

**Thoughts:** After attempting to implement checkCollision, I found that there was a better way to check for collision that is easily compatible with the current trajectory following method. 

**Link to work:** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 25: June 15, Saturday

**Today's Progress**: After attempting to test program with an altered block positioning, the joint_trajectory_action server was not properly obtaining joint_angles from the robot. Had to troubleshoot issue. 

**Thoughts**: I believe it is the fact that my VM is using more CPUs than what my computer’s host possesses that is causing the problem which can be solved by transferring the VM to another computer. 

**Link(s) to work**: [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 26: June 16, Sunday

**Today's Progress**: Spent time transferring VM to desktop computer. 

**Thoughts**: I learned just how much faster ethernet functions than wifi after downloading an .ova file over wifi and over ethernet. 

**Link(s) to work**: [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)



### Day 27: June 17, Monday

**Today's Progress**: Got VM up and running once again, continued to have problems with joint_trajectory_action_server due to hardware limitations. However, I continued to work on making the collision detection and trajectory following method work in conjunction with each other. 

**Thoughts:**: I realized that many sharpened Python skills are being put to good use throughout completing the projects. It is much easier to work through problems and pinpoint which bits don’t make any sense. 

**Link to work:** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 28: June 18, Tuesday

**Today's Progress**: Continued to work through the trajectory following method, trying a different way to create a trajectory. 

**Thoughts**: I learned that you should never eliminate code that functions properly. I had to go back and rewrite the previously functioning program. I also learned the value of version control. 

**Link(s) to work**: [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 29: June 19, Wednesday

**Today's Progress**: Attempted to begin collision avoidance method. Tested a new way in which I could ask if the collision was not valid that the trajectory be cut in half in order to create a new trajectory in which the first point would be the robots current position and the second point would be positioned above the blocks. 

**Thoughts** Attempted to implement the new motion, needs work. 

**Link(s) to work: **[Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 30: June 20, Thursday

**Today's Progress**: Attempted to finish collision avoidance method, having the end point of the trajectory will be the same in both the first trajectory and the altered trajectory. 

**Thoughts:** Worked to implement collision detection first, in order to modify trajectory and move arm to waypoint (joint_position that is higher than the blocks- or the original midpoint plus a couple of radians in the z direction)

**Link to work:** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 31: June 21, Friday

**Today's Progress**: Continued to work through the collision detection method, attempting to also finalize three point trajectory. Also read over material to install cameras. 

**Thoughts**: I really struggled with CSS, but, overall, I feel like I am slowly getting better at it. Canvas is still new for me, but I managed to figure out some basic functionality.

**Link(s) to work**: [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 32: June 22, Saturday

**Today's Progress**: Created method to randomize starting position, however collision detection and the trajectory’s midpoint have not been finalized. 

**Thoughts** Looking back, I would have struggled to resolve the issues that I have been facing in the amount of time that I can easily resolve them now. I feel proud of how much I have improved over the past 32 days. 

**Link(s) to work:** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 33: June 23, Sunday


**Today's Progress**: Worked on collision avoidance trajectory, attempted to seamlessly mesh all methods.  learned how to properly upload 100 Days of Coding Challenge items to Github repository. 

**Thoughts:** I believe I have grown tremendously since the start of the challenge and cannot wait to continue my journey. 

**Link to work:** [Baxter Collision Detection](https://github.com/bbdancer365/100-days-of-code/edit/master/baxter_collision.py)


### Day 34: June 24, Monday

**Today's Progress**: Created new method for the new trajectory, where which the current robot_position would move from the 2nd point in the original trajectory to an upper position above the blocks. Following this, the method has it move to the right and then form a new trajectory to the initial endpoint. 




